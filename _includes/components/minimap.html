<div class="minimap-container" id="minimap">
  <div class="minimap-content" id="minimap-content">
    <!-- Minimap items will be dynamically generated -->
  </div>
</div>

<style>
.minimap-container {
  width: 80px;
  height: calc(100vh - 4rem);
  background: rgba(255, 255, 255, 0.95);
  display: none;
  flex-direction: column;
  overflow: hidden;
  flex-shrink: 0;
}


.minimap-content {
  flex: 1;
  padding: 0.5rem;
  overflow-y: auto;
  position: relative;
  height: 100%;
}

.minimap-item {
  background: #e5e7eb;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  position: absolute;
  min-height: 4px;
  box-sizing: border-box;
}

.minimap-item:hover {
  background: #d1d5db;
  transform: scale(1.05);
}

.minimap-item.active {
  background: #3b82f6;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}

.minimap-item.publication {
  background: #dbeafe;
}

.minimap-item.project {
  background: #fef3c7;
}

.minimap-item.news {
  background: #fce7f3;
}

.minimap-item.all {
  background: #f3f4f6;
}

/* Hover effects for minimap tiles */
.minimap-container:hover .minimap-item {
  opacity: 0.3;
  transition: opacity 0.2s ease;
}

.minimap-container:hover .minimap-item.publication {
  opacity: 1;
  background: #2563eb;
  transition: all 0.2s ease;
}

.minimap-container:hover .minimap-item.project {
  opacity: 1;
  background: #d97706;
  transition: all 0.2s ease;
}

.minimap-container:hover .minimap-item.news {
  opacity: 1;
  background: #be185d;
  transition: all 0.2s ease;
}

.minimap-container:hover .minimap-item.all {
  opacity: 1;
  background: #6b7280;
  transition: all 0.2s ease;
}


/* Show minimap only on desktop and when masonry is present */
@media (min-width: 1024px) {
  .minimap-container {
    display: flex;
  }
}

/* Hide minimap on mobile */
@media (max-width: 1023px) {
  .minimap-container {
    display: none !important;
  }
}

/* Minimap scrollbar styling */
.minimap-content::-webkit-scrollbar {
  width: 4px;
}

.minimap-content::-webkit-scrollbar-track {
  background: transparent;
}

.minimap-content::-webkit-scrollbar-thumb {
  background: #d1d5db;
  border-radius: 2px;
}

.minimap-content::-webkit-scrollbar-thumb:hover {
  background: #9ca3af;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const minimap = document.getElementById('minimap');
  const minimapContent = document.getElementById('minimap-content');
  const mainContent = document.querySelector('.content, .container, .pubs-list');
  
  if (!minimap || !mainContent) return;
  
  let masonryItems = [];
  let isUpdating = false;
  
  // Initialize minimap
  function initMinimap() {
    // Find all masonry items
    masonryItems = Array.from(document.querySelectorAll('.pub-item, .project-card, .grid-item'));
    
    if (masonryItems.length === 0) {
      minimap.style.display = 'none';
      return;
    }
    
    // Get actual masonry container dimensions
    const containerRect = mainContent.getBoundingClientRect();
    const containerHeight = mainContent.scrollHeight;
    const containerWidth = mainContent.offsetWidth;
    
    // Calculate minimap scale factors
    const minimapHeight = minimapContent.offsetHeight - 16; // Account for padding (0.5rem * 2)
    const minimapWidth = minimapContent.offsetWidth - 16; // Account for padding (0.5rem * 2)
    const scaleY = minimapHeight / containerHeight;
    const scaleX = minimapWidth / containerWidth;
    const scale = Math.min(scaleX, scaleY); // Use uniform scale to maintain aspect ratio
    
    // Get actual positions and dimensions of all items
    const itemsData = masonryItems.map((item, index) => {
      const rect = item.getBoundingClientRect();
      const containerRect = mainContent.getBoundingClientRect();
      return {
        element: item,
        index: index,
        top: rect.top - containerRect.top + mainContent.scrollTop,
        left: rect.left - containerRect.left,
        height: item.offsetHeight,
        width: item.offsetWidth,
        bottom: rect.bottom - containerRect.top + mainContent.scrollTop
      };
    });
    
    // Find the leftmost and rightmost positions to center the content
    const leftmost = Math.min(...itemsData.map(item => item.left));
    const rightmost = Math.max(...itemsData.map(item => item.left + item.width));
    const contentWidth = rightmost - leftmost;
    
    // Sort by top position, then by left position
    itemsData.sort((a, b) => {
      if (Math.abs(a.top - b.top) < 5) {
        return a.left - b.left;
      }
      return a.top - b.top;
    });
    
    // Create minimap items with accurate positioning
    minimapContent.innerHTML = '';
    
    // Calculate offset to center the content
    const scaledContentWidth = contentWidth * scale;
    const offsetX = Math.max(0, (minimapWidth - scaledContentWidth) / 2);
    
    itemsData.forEach((itemData) => {
      const minimapItem = document.createElement('div');
      minimapItem.className = 'minimap-item';
      minimapItem.dataset.index = itemData.index;
      
      // Calculate scaled dimensions and position using uniform scale
      const scaledHeight = Math.max(6, itemData.height * scale);
      const scaledWidth = Math.max(20, itemData.width * scale);
      const scaledTop = itemData.top * scale;
      const scaledLeft = (itemData.left - leftmost) * scale + offsetX;
      
      // Apply styles
      minimapItem.style.position = 'absolute';
      minimapItem.style.top = `${scaledTop}px`;
      minimapItem.style.left = `${scaledLeft}px`;
      minimapItem.style.height = `${scaledHeight}px`;
      minimapItem.style.width = `${scaledWidth}px`;
      
      // Determine item type for styling based on data-type attribute
      const dataType = itemData.element.getAttribute('data-type');
      if (dataType === 'pub' || dataType === 'publication') {
        minimapItem.classList.add('publication');
      } else if (dataType === 'project') {
        minimapItem.classList.add('project');
      } else if (dataType === 'news') {
        minimapItem.classList.add('news');
      } else {
        minimapItem.classList.add('all');
      }
      
      // Add click handler
      minimapItem.addEventListener('click', () => {
        scrollToItem(itemData.element);
      });
      
      minimapContent.appendChild(minimapItem);
    });
  }
  
  // Scroll to specific item
  function scrollToItem(item) {
    if (isUpdating) return;
    
    const containerRect = mainContent.getBoundingClientRect();
    const itemRect = item.getBoundingClientRect();
    const scrollTop = mainContent.scrollTop + (itemRect.top - containerRect.top);
    
    mainContent.scrollTo({
      top: scrollTop,
      behavior: 'smooth'
    });
  }
  
  
  // Update which item is currently active
  function updateActiveItem() {
    const containerRect = mainContent.getBoundingClientRect();
    const containerCenter = containerRect.top + containerRect.height / 2;
    
    let activeIndex = -1;
    let minDistance = Infinity;
    
    masonryItems.forEach((item, index) => {
      const itemRect = item.getBoundingClientRect();
      const itemCenter = itemRect.top + itemRect.height / 2;
      const distance = Math.abs(itemCenter - containerCenter);
      
      if (distance < minDistance) {
        minDistance = distance;
        activeIndex = index;
      }
    });
    
    // Update active state
    document.querySelectorAll('.minimap-item').forEach((item, index) => {
      item.classList.toggle('active', index === activeIndex);
    });
  }
  
  // Throttled scroll handler
  let scrollTimeout;
  function handleScroll() {
    if (isUpdating) return;
    
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
      updateActiveItem();
    }, 10);
  }
  
  // Add hover effects for filter buttons
  function addFilterHoverEffects() {
    const filterButtons = document.querySelectorAll('.works-nav-button, .mobile-works-filter-btn');
    
    filterButtons.forEach(button => {
      button.addEventListener('mouseenter', () => {
        const filterType = button.getAttribute('data-filter');
        const minimapItems = document.querySelectorAll('.minimap-item');
        
        minimapItems.forEach(item => {
          let shouldHighlight = false;
          
          if (filterType === 'all') {
            shouldHighlight = true;
          } else if (filterType === 'pub' && item.classList.contains('publication')) {
            shouldHighlight = true;
          } else if (filterType === 'project' && item.classList.contains('project')) {
            shouldHighlight = true;
          } else if (filterType === 'news' && item.classList.contains('news')) {
            shouldHighlight = true;
          }
          
          if (shouldHighlight) {
            item.style.opacity = '1';
            // Darken the matching tiles
            if (item.classList.contains('publication')) {
              item.style.background = '#2563eb';
            } else if (item.classList.contains('project')) {
              item.style.background = '#d97706';
            } else if (item.classList.contains('news')) {
              item.style.background = '#be185d';
            } else if (item.classList.contains('all')) {
              item.style.background = '#6b7280';
            }
          } else {
            item.style.opacity = '0.3';
          }
        });
      });
      
      button.addEventListener('mouseleave', () => {
        const minimapItems = document.querySelectorAll('.minimap-item');
        
        minimapItems.forEach(item => {
          item.style.opacity = '';
          // Reset to original colors
          if (item.classList.contains('publication')) {
            item.style.background = '#dbeafe';
          } else if (item.classList.contains('project')) {
            item.style.background = '#fef3c7';
          } else if (item.classList.contains('news')) {
            item.style.background = '#fce7f3';
          } else if (item.classList.contains('all')) {
            item.style.background = '#f3f4f6';
          }
        });
      });
    });
  }

  // Initialize when masonry is ready
  function waitForMasonry() {
    const checkMasonry = () => {
      const items = document.querySelectorAll('.pub-item, .project-card, .grid-item');
      if (items.length > 0) {
        // Wait a bit more for masonry to fully render
        setTimeout(() => {
          initMinimap();
          addFilterHoverEffects();
          mainContent.addEventListener('scroll', handleScroll, { passive: true });
        }, 500);
      } else {
        setTimeout(checkMasonry, 100);
      }
    };
    checkMasonry();
  }
  
  // Start initialization
  waitForMasonry();
  
  // Re-initialize on window resize
  window.addEventListener('resize', () => {
    setTimeout(() => {
      initMinimap();
    }, 100);
  });
  
  // Re-initialize when masonry layout changes
  const observer = new MutationObserver(() => {
    if (document.querySelectorAll('.pub-item, .project-card, .grid-item').length !== masonryItems.length) {
      setTimeout(() => {
        initMinimap();
      }, 100);
    }
  });
  
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
});
</script>
